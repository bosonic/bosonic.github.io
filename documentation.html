<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="/images/cabin.png">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <link href="/styles/main.css" rel="stylesheet">

    <title>Bosonic Web Component</title>
    <meta name="description" content="undefined">
  </head>
  <body>
    
    <div id="header">

    <a href="index.html" id="logo">Bosonic web component</a>


  <ul id="nav">
    <li><a href="index.html">Home</a></li>
    <li class="nav-separator">|</li>
    <li><a href="getting-started.html">Getting Started</a></li>
    <li class="nav-separator">|</li>
    <li><a href="demos.html">Demos</a></li>
    <li class="nav-separator">|</li>
    <li><a href="documentation.html">Documentation</a></li>
    <li class="nav-separator">|</li>
    <li><a href="components.html">Components</a></li>
    <li class="nav-separator">|</li>
    <li><a href="contribute.html" class="last">Contribute</a></li>
  </ul>
</div>

    <div id="content" class="markdown">


<h1>Documentation</h1>


  

  

  

    <h2><a name="templates" class="anchor" href="#templates"><span class="header-link"></span></a>Templates</h2>
<p>If you put some markup in the <code>&lt;template&gt;</code> section, you will have access to a <code>this.template</code> property in your <code>&lt;script&gt;</code>, which is a polyfilled HTML template element. We will use this to bring more content on screen with our element:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-hello-world&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;style&gt;</span>    
    <span class="nt">&lt;/style&gt;</span>
    <span class="nt">&lt;template&gt;</span>
        <span class="nt">&lt;h3&gt;</span>Hello, world!<span class="nt">&lt;/h3&gt;</span>
        <span class="nt">&lt;p&gt;</span>Lorem ipsum<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/template&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="p">({</span>
            <span class="nx">createdCallback</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">template</span><span class="p">.</span><span class="nx">content</span><span class="p">.</span><span class="nx">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>


  

  

  

    <p>Bosonic&#39;s philosophy is to enable developers to build Web Components as close as possible to the current spec. Therefore, Bosonic aims to not become a dependency: ideally, when browsers will implement all Web Components spec, you&#39;ll be able to drop Bosonic and to use your components directly.</p>
<p>For commodity reasons, we&#39;ll start with the boilerplate element we have generated in the <a href="getting-started.html">Getting started</a> section, and describe how to build a powerful element.</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-hello-world&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;style&gt;</span>

    <span class="nt">&lt;/style&gt;</span>
    <span class="nt">&lt;template&gt;</span>

    <span class="nt">&lt;/template&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="p">({</span>

        <span class="p">});</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<p>First, you can see that <code>&lt;element&gt;</code> has a <code>name</code> attribute: it is of course mandatory, as it specifies the name of the HTML tag you’ll instantiate in markup. Per spec, it <strong>must</strong> contain a &quot;-&quot;.</p>
<p>Second, you can see that the <code>&lt;script&gt;</code> element already contains something that is called an Object Expression: it is an expression that evals to an object literal. Per spec again, this Object Expression <strong>must</strong> be the last expression in your <code>&lt;script&gt;</code>.</p>
<p>All methods &amp; properties included in this Object Expression will constitute the API of your new element. If, for example, we add a <code>sayHello</code> method:</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">({</span>
    <span class="nx">sayHello</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>We put our new element in use in a HTML page:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-hello-world&gt;&lt;/b-hello-world&gt;</span>

<span class="nt">&lt;script&gt;</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;WebComponentsReady&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">hello</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;b-hello-world&#39;</span><span class="p">);</span>
        <span class="nx">hello</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span>
    <span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
</code></pre>
<p>You will see a nice &#39;Hello&#39; logged to the console!</p>
<p>There are two things to notice in this example:</p>
<ul>
<li>Custom Elements are at first <code>HTMLUnknownElement</code> and are eventually upgraded by the polyfills. It means that you have to listen to the <code>WebComponentsReady</code> event before attempting to use your elements with JavaScript.</li>
<li>Custom Elements, once upgraded, behave like standard elements: they can be queried with DOM methods.</li>
</ul>


  

  

    <h2><a name="lifecycle-callbacks" class="anchor" href="#lifecycle-callbacks"><span class="header-link"></span></a>Lifecycle callbacks</h2>
<p>Lifecycle callbacks are special methods defined by the Custom Elements specification which fire when the element go through specific changes during its lifetime:</p>
<ul>
<li><code>createdCallback()</code> is called when a custom element is created.</li>
<li><code>attachedCallback()</code> is called when a custom element is inserted into a DOM subtree.</li>
<li><code>detachedCallback()</code> is called when a custom element is removed from a DOM subtree.</li>
<li><code>attributeChangedCallback(attributeName)</code> is called when a custom element&#39;s attribute value has changed.</li>
</ul>
<p>Bosonic supports another callback, <code>childListChangedCallback(removedNodes, addedNodes)</code>, which is called when a user of your element updates its DOM children. It is not defined in the spec though.</p>
<p>We will now use the <code>createdCallback()</code> to display something on screen:</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">({</span>
    <span class="nx">createdCallback</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>If you refresh your browser, you should now see &#39;Hello&#39; on screen, and if you inspect the HTML, you will see this:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-hello-world&gt;</span>
    Hello
<span class="nt">&lt;/b-hello-world&gt;</span>
</pre></div>
</code></pre>
<p>The takeaway is that <code>this</code> here refers to your element: you can therefore use all DOM methods on it.</p>


  

  

    <h2><a name="shadow-dom" class="anchor" href="#shadow-dom"><span class="header-link"></span></a>Shadow DOM</h2>
<p>In the previous example, we appended noded directly to our element: it may be desired in some cases, but we will often prefer to hide the implementation in terms of markup of our element. This is what Shadow DOM is done for. Bosonic provides a powerful polyfill for Shadow DOM, which you can use like this:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-hello-world&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;style&gt;</span>    
    <span class="nt">&lt;/style&gt;</span>
    <span class="nt">&lt;template&gt;</span>
        <span class="nt">&lt;h3&gt;</span>Hello, world!<span class="nt">&lt;/h3&gt;</span>
        <span class="nt">&lt;p&gt;</span>Lorem ipsum<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/template&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="p">({</span>
            <span class="nx">createdCallback</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">createShadowRoot</span><span class="p">();</span>
                <span class="nx">root</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">template</span><span class="p">.</span><span class="nx">content</span><span class="p">.</span><span class="nx">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<p>Here, we append the template&#39;s content directly to a shadow root. Of course, if you inspect the HTML in a browser that does not support Shadow DOM natively, you will see some markup: it is the <strong>composed DOM</strong>, generated by Bosonic from our shadow root and the light DOM, which is the user-provided children of our custom element.</p>
<p>You can define <strong>insertion points</strong> in your Shadow DOM with the <code>&lt;content&gt;</code> element, in which Bosonic will pull Light DOM nodes. For example:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-hello-world&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;style&gt;</span>    
    <span class="nt">&lt;/style&gt;</span>
    <span class="nt">&lt;template&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;title&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;content</span> <span class="na">select=</span><span class="s">&quot;h3&quot;</span><span class="nt">&gt;&lt;/content&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;content&gt;&lt;/content&gt;</span>
    <span class="nt">&lt;/template&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="p">({</span>
            <span class="nx">createdCallback</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">createShadowRoot</span><span class="p">();</span>
                <span class="nx">root</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">template</span><span class="p">.</span><span class="nx">content</span><span class="p">.</span><span class="nx">cloneNode</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-hello-world&gt;</span>
    <span class="nt">&lt;h3&gt;</span>Hello world<span class="nt">&lt;/h3&gt;</span>
    <span class="nt">&lt;p&gt;</span>Lorem ipsum<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;button&gt;</span>Ok<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/b-hello-world&gt;</span>
</pre></div>
</code></pre>
<p>If you inspect the rendered composed DOM in a no-shadowDOM browser, you will see something like this:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-hello-world&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;title&quot;</span><span class="nt">&gt;</span>
        Hello world
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;p&gt;</span>Lorem ipsum<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;button&gt;</span>Ok<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/b-hello-world&gt;</span>
</pre></div>
</code></pre>


  

  

    <h2><a name="styling-elements" class="anchor" href="#styling-elements"><span class="header-link"></span></a>Styling elements</h2>
<p>This section describes how to style your Custom Elements, focusing essentially on how to style Shadow DOM and on how Bosonic transpiles these new CSS rules into something current browsers can understand. </p>
<p>Please note that Shadow DOM spec is still a draft, and so CSS rules may change. We&#39;ll try to keep Bosonic in sync with these potential changes. </p>
<p>Keep in mind that some of these rules are not easily shimable, therefore Bosonic support of these rules is limited. To be on the safe side, use only rules that are documented here.</p>
<h3><a name="user-provided-styles" class="anchor" href="#user-provided-styles"><span class="header-link"></span></a>User-provided styles</h3>
<p>Users of your Custom Element can define styles on it using the element&#39;s name as a selector:</p>
<pre><code class="lang-css"><div class="highlight"><pre><span class="nt">b-bar</span> <span class="p">{</span>
    <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#ccc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>It works out-of-the-box, there is no need to use Bosonic to transpile these rules.</p>
<h3><a name="styling-the-host-element" class="anchor" href="#styling-the-host-element"><span class="header-link"></span></a>Styling the host element</h3>
<p>The <code>:host</code> pseudo-class allows you to select and style an element hosting a shadow tree ; it must therefore be used to style your Custom Element from within its definition:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-bar&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="nd">:host</span> <span class="p">{</span>
      <span class="c">/* b-bar will get a border */</span>
      <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#ccc</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nd">:host:hover</span> <span class="p">{</span>
      <span class="k">border-color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;template&gt;</span>
    ...
  <span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<p>As you can see in the above example, the form <code>:host:&lt;state&gt;</code> allows you to provide specific styles for &quot;classic&quot; user-driven states.</p>
<p>You can use the <code>:host(&lt;selector&gt;)</code> functional pseudo-class to match the host if it matches the selector argument. For example:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-bar&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="nd">:host</span><span class="o">(</span><span class="nc">.foo</span><span class="o">)</span> <span class="p">{</span>
      <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#ccc</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;template&gt;</span>
    ...
  <span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-bar</span> <span class="na">class=</span><span class="s">&quot;foo&quot;</span><span class="nt">&gt;&lt;/b-bar&gt;</span>
</pre></div>
</code></pre>
<h3><a name="theming-an-element" class="anchor" href="#theming-an-element"><span class="header-link"></span></a>Theming an element</h3>
<p>The <code>:host-context(&lt;selector&gt;)</code> functional pseudo-class matches the host element if it or any of its ancestors matches the selector argument. It can therefore be useful for theming.</p>
<pre><code class="lang-css"><div class="highlight"><pre><span class="nd">:host-context</span><span class="o">(</span><span class="nc">.warning</span><span class="o">)</span> <span class="p">{</span>
    <span class="k">background-color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;body</span> <span class="na">class=</span><span class="s">&quot;warning&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;b-bar</span> <span class="na">class=</span><span class="s">&quot;foo&quot;</span><span class="nt">&gt;&lt;/b-bar&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>
</code></pre>
<p><strong>Note:</strong> <code>:host-context</code> has recently be renamed from <code>:ancestor</code> in the spec. Bosonic still supports <code>:ancestor</code>, but you&#39;d better use <code>:host-context</code>.</p>
<h3><a name="styling-shadow-dom-markup-from-inside" class="anchor" href="#styling-shadow-dom-markup-from-inside"><span class="header-link"></span></a>Styling Shadow DOM markup from inside</h3>
<p>Shadow DOM features scoped styling: styles defined inside the scope of the shadow tree don&#39;t leak into the document DOM, and document styles don&#39;t leak into the shadow DOM. </p>
<p>Unfortunately, emulating scoped styling is near-to-impossible: Bosonic transpiles these styles by prepending selectors with the element tag name, but this does not enforce lower bound encapsulation. Keep that in mind when authoring your elements (more on this later).</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-bar&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="nt">p</span><span class="nc">.warning</span> <span class="p">{</span>
      <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;warning&quot;</span><span class="nt">&gt;</span>Bla bla<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<p>Bosonic will transpile this rule to:</p>
<pre><code class="lang-css"><div class="highlight"><pre><span class="nt">b-bar</span> <span class="nt">p</span><span class="nc">.warning</span> <span class="p">{</span>
    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<h3><a name="styling-shadow-projected-content" class="anchor" href="#styling-shadow-projected-content"><span class="header-link"></span></a>Styling shadow-projected content</h3>
<p>The <code>::content</code> pseudo-element allows you to target Light DOM nodes distributed into the shadow tree using the <code>&lt;content&gt;</code> element:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-bar&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="o">:</span><span class="nd">:content</span> <span class="nt">div</span> <span class="p">{</span>
      <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;content</span> <span class="na">select=</span><span class="s">&quot;div&quot;</span><span class="nt">&gt;&lt;/content&gt;</span>
  <span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-bar&gt;</span>
    <span class="nt">&lt;div&gt;</span>This is red!<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/b-bar&gt;</span>
</pre></div>
</code></pre>
<p><strong>Warning:</strong> Bosonic will transpile this rule to:</p>
<pre><code class="lang-css"><div class="highlight"><pre><span class="nt">b-bar</span> <span class="nt">div</span> <span class="p">{</span>
    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>It can cause two problems: one, the style will be applied to Shadow DOM divs too:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-bar&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="o">:</span><span class="nd">:content</span> <span class="nt">div</span> <span class="p">{</span>
      <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;content</span> <span class="na">select=</span><span class="s">&quot;div&quot;</span><span class="nt">&gt;&lt;/content&gt;</span>
    <span class="nt">&lt;div&gt;</span>This is red too, but it shouldn&#39;t...<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-bar&gt;</span>
    <span class="nt">&lt;div&gt;</span>This is red!<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/b-bar&gt;</span>
</pre></div>
</code></pre>
<p>Therefore, you should use classes to avoid this problem:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-bar&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="o">:</span><span class="nd">:content</span> <span class="nt">div</span> <span class="p">{</span>
      <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">div</span><span class="nc">.shadow-blue</span> <span class="p">{</span>
      <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;content</span> <span class="na">select=</span><span class="s">&quot;div&quot;</span><span class="nt">&gt;&lt;/content&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;shadow-blue&quot;</span><span class="nt">&gt;</span>This will be blue!<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-bar&gt;</span>
    <span class="nt">&lt;div&gt;</span>This is red!<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/b-bar&gt;</span>
</pre></div>
</code></pre>
<p>Second problem: </p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;element</span> <span class="na">name=</span><span class="s">&quot;b-bar&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;</span>
    <span class="o">:</span><span class="nd">:content</span> <span class="nt">div</span> <span class="p">{</span>
      <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;content</span> <span class="na">select=</span><span class="s">&quot;div.foo&quot;</span><span class="nt">&gt;&lt;/content&gt;</span>
  <span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/element&gt;</span>
</pre></div>
</code></pre>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;b-bar&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;one&quot;</span> <span class="na">class=</span><span class="s">&quot;foo&quot;</span><span class="nt">&gt;</span>...<span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;two&quot;</span><span class="nt">&gt;</span>...<span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;three&quot;</span> <span class="na">class=</span><span class="s">&quot;foo&quot;</span><span class="nt">&gt;</span>...<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/b-bar&gt;</span>
</pre></div>
</code></pre>
<p>In this case, only the divs with a <code>foo</code> class will be distributed (<code>#one</code> and <code>#three</code>); the <code>::content div</code> selector should therefore match only these distributed nodes. Alas, as Bosonic will transpile this selector to <code>b-bar div</code>, <code>#two</code> will be styled too. To avoid this, you should use classes to distinguish between these divs:</p>
<pre><code class="lang-css"><div class="highlight"><pre><span class="o">:</span><span class="nd">:content</span> <span class="nt">div</span><span class="nc">.foo</span> <span class="p">{</span>
    <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>


  

  


    </div>

    <div id="footer">
        <p>© 2014 Bosonic Authors. Code licensed under the <a href="https://github.com/bosonic/bosonic/blob/master/LICENSE">MIT License</a>. Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
    </div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js" type="text/javascript"></script>
    <script src="/scripts/main.js" type="text/javascript"></script>
    <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		  ga('create', 'UA-3319204-5', 'bosonic.github.io');
		  ga('send', 'pageview');

	</script>
  </body>
</html>
